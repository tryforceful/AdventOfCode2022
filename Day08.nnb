{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "Get Input\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nimport * as fs from \"fs\";\n\nlet data: string\nlet input: string[];\n\ndata = fs.readFileSync(\"./inputs/day08.txt\", \"utf8\");\ninput = data.split(\"\\n\").slice(0, -1);\n\nconst inputgrid = input.map(str => Array.from(str).map(Number))\n\ninputgrid //99x99\n\nconst markers = new Array(99).fill([]).map(x => new Array(99).fill(0))\n\nfor(let i = 0; i < 99; i++) {\n\n  let fromleft = -1, fromright = -1, fromtop = -1, frombottom = -1;\n\n  for(let j = 0; j < 99; j++) {\n\n    fromleft = measureTree(i, j, fromleft);\n    fromright = measureTree(i, 98-j, fromright);\n    fromtop = measureTree(j, i, fromtop);\n    frombottom = measureTree(98-j, 98-i, frombottom);\n  }\n}\n\nfunction measureTree(i: number, j: number, highest_so_far: number) {\n  const thistree = inputgrid[i][j];\n  if (thistree > highest_so_far) {\n    // this tree can be seen\n    markers[i][j] = 1; //true\n\n    //update the highest so far\n    return thistree;\n  }\n  else return highest_so_far;\n}\n\nmarkers.map(x => x.join(''))\n\nconst sum = (a,c) => a+c;\n\nmarkers.map((x) => x.reduce(sum, 0)).reduce(sum, 0) // Part 1 answer\n\n\n// Part 2\n\n\nconst scenicscores = new Array(99).fill([]).map((x) => new Array(99).fill(0));\n\nfor (let i = 0; i < 99; i++) {\n  for (let j = 0; j < 99; j++) {\n    scenicscores[i][j] = calculateScenicScore(i, j);\n  }\n}\n\nfunction calculateScenicScore(x:number, y:number): number {\n\n  const height_of_current_tree = inputgrid[x][y];\n\n  let downcount = 1;\n  for (let z = x + 1; z < 99; z++) {\n    //down\n    if (z >= 98) break;\n    if (inputgrid[z][y] < height_of_current_tree) downcount++;\n    else break;\n  }\n\n  let upcount = 1;\n  for (let z = x - 1; z >= 0; z--) {\n    //up\n    if (z <= 0) break;\n    if (inputgrid[z][y] < height_of_current_tree) upcount++;\n    else break;\n  }\n\n  let leftcount = 1;\n  for (let z = y + 1; y < 99; z++) {\n    //left\n    if (z >= 98) break;\n    if (inputgrid[x][z] < height_of_current_tree) leftcount++;\n    else break;\n  }\n\n  let rightcount = 1;\n  for (let z = y - 1; y >= 0; z--) {\n    //right\n    if (z <= 0) break;\n    if (inputgrid[x][z] < height_of_current_tree) rightcount++;\n    else break;\n  }\n\n  return downcount * upcount * leftcount * rightcount;\n}\n\nscenicscores.map((x) => x.join(\",\"));\n\nconst max = (a,c) => Math.max(a,c)\n\nscenicscores.map((x) => x.reduce(max, 0)).reduce(max, 0);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33m527340\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}